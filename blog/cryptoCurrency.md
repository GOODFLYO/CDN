---
title: cryptoCurrency
date: 2022-05-20 13:16:57
tags:
- 加密货币
categories:
- 区块链
---
# 加密货币复习

## 区块链发展历程

**区块链1.0 可编程货币**

比特币为代表的货币区块链技术为1.0

08年，中本聪详细描述了如何创建一套[去中心化](https://baike.baidu.com/item/去中心化)的电子交易体系，且这种体系不需要创建在交易双方相互信任的基础之上。分布式账本技术的实施导致其第一个明显的应用：加密货币。比特币用作“互联网现金”，一种数字支付系统，可以被视为“货币互联网”的推动者。相关数字货币：比特币BTC、莱特币LTC、

**应用**：利用密码学货币进行数字化支付，例如转账、汇款，起到公共账本的作用

**区块链2.0 可编程金融**

以太坊为代表的合同区块链技术为2.0

自比特币诞生后，人们认识到比特币的底层技术区块链天生可以为**智能合约**提供可信的执行环境。数字货币开始与智能合约相结合，使得该区块链技术在金融领域有了更广泛的应用场景，同时该技术应用下的交易流程得到了优化。

应用：可在以太坊中创建去中心化的程序、自治组织以及部署、使用智能合约

**区块链3.0 可编程社会**

实现完备权限控制和安全保障的Hyperledger项目代表3.0

区块链3.0是智能化物联网时代，不同于区块链1.0和区块链2.0只在金融领域被应用，区块链3.0超出金融领域，为各种行业提供去中心化解决方案。区块链的应用领域扩展到人类生活的方方面面，不再依靠某个第三人或者机构获取信任，实现信息的共享，提高整个系统的运转效率。

 

## **为什么说区块链技术的应用是从信息互联网到价值互联网？**

区块链提供了一种加密安全的端到端支付流程，具有交易不变性和信息共享的一致性。价值互联网设想了一个价值移动和交换的世界。借助价值互联网，外币支付等价值交易可以立即发生。这不仅仅是金钱。价值互联网可以实现对某人有价值的任何资产的交换，包括证券、知识产权、音乐、科学发现等。区块链通过密码学、分布式共识、链式结构等机制实现了确权及允许任何类型的资产从一方直接转移到另一方，而无需中间人。转移是经过验证的、永久的并立即完成的。

有了“确权”和“交换”，价值就能完成了。而区块链正是解决了这两个问题，才成为了第三代互联网价值互联网的基石，让价值互联网成为可能和现实。

 

## **区块链的部署有哪三种形势，每种部署形式的特点，国内区块链应用以哪种部署形势为主？**

**公有链：**全世界任何拥有联网计算机的用户都可以在任何时候加入或退出网络。

任意读取区块数据、执行交易，参与网络共识过程。**共识算法：**PoW、PoS等。

**联盟链：**由若干机构组成利益相关的联盟，共同参与并维护具有准入机制的多中心化区块链。区块数据读写、参与记账规则等需要由联盟成员节点共同决定。联盟链上的交易只需要少量节点达成共识即可，且节点间信任度比公有链要高。与公有链相比，其效率也有很大的提升。**共识算法**：PBFT、Raft等。

**私有链：**写入权限仅在一个组织手里的区块链，而读取权限或者对外开放，或者被任意程度地进行了限制。

国内区块链应用以联盟链为主。

 

## **以区块链六层参考架构为例说明每层主要功能及用途。**

应用层：可编程货币，可编程合约，可编程社会
 合约层：脚本代码，算法机制，智能合约—>智能合约
 激励层：发行机制，分配机制—>经济激励
 共识层：PoW，PoS，DPoS，PBFT—>分布式信任，众包协作
 网络层：P2P网络，传播机制，验证机制—>分布式自治
 数据层：数据区块，链式结构，时间戳，哈希函数，默克尔树，非对称加密—>数据安全

## **比特币与区块链的关系是什么？对比特币每个区块的数据结构进行说明，并给出block header的每个字段长度及意义。**

比特币是一种数字货币,而区块链是一种技术;区块链是比特币的底层技术,而比特币是区块链技术的第一个应用.

区块数据结构参考下图，对区块头的每个字段意义要求记住。

![img](file:///C:/Users/GOODFLY/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg)!

## **简述比特币密钥和地址的生成过程，为什么能够从地址推导出公钥哈希值？**

**私钥生成**:私钥其本质就是一个256位的由0和1组成的随机数，这个随机数是怎么产生的不重要，只要是不可预测和不可重复的都可以，私钥的格式是将这个256位的随机数以64位十六进制数显示。 

**公钥生成:**公钥是将私钥通过一个椭圆曲线乘法的算法计算得来，这是一个不可逆转的过程。

**地址生成:**比特币地址是由公钥经过一系列单向的哈希算法得到。哈希算法是一种单向函数，可以接收任意长度的输入产生指纹或哈希。由公钥生成比特币地址时使用的算法是SHA256和RIPEMD160。公钥先进行SHA256和RIPEMD160后得到公钥哈希,在经过Base58check编码就可以得到比特币地址。将地址经过逆向变换就可以得公钥的哈希值.

 

## **简述比特币钱包的作用和种类？** 

广义上，钱包是一个应用程序，为用户提供交互界面。钱包控制用户访问权限，管理密钥和地址，跟踪余额以及创建和签名交易。

 

## **简述比特币的交易流程，指出锁定脚本和解锁脚本放置的位置，并以P2PKH为例说明交易脚本的执行过程，并给出压栈出栈的顺序（可以手绘照相插入到word文档中）**

**1****、比特币交易的创建：**比特币交易可以被任何人在线上或线下创建，但要使交易有效，则需要由一个或多个私钥签名，表明具备交易中发送方地址所指向的比特币资金的所有权。**2、比特币交易广播到整个P2P网络：**一笔比特币交易数经过签名但不会泄露任何信息，可以被公开传播。每个节点都将从网络中收集交易数据并广播给相连接的其他节点。在传播交易前，节点均进行独立验证，确保有效性，异常交易无法传播。比特币网络是点对点网络，交易的扩散迅速，指数级扩散。**3、比特币交易验证与挖矿：**每个节点维护一个交易池，存放临时未经确认的交易。节点从交易池中选择一系列交易构成一个区块，基于自身算力找到一个具有足够难度的工作量证明，找到后向所有节点广播此区块。**4、比特币交易确认：**当包含在区块中的所有交易都是有效的且交易输入未动用，其他节点才会接受这个新的区块，链接到自己的区块链的尾部。**5、交易记录：**交易得到全网的6个确认之后，永久的记录在区块链中。

下图中指出了解锁脚本在输入列表里，锁定脚本在输出列表里

P2PKH脚本的执行指针执行过程和栈上变化如下：

![http://8btc.com/data/attachment/portal/201505/29/135554tdyyldywn0f0lyix.png](file:///C:/Users/GOODFLY/AppData/Local/Temp/msohtmlclip1/01/clip_image005.jpg)

## **比特币的共识机制是什么？比特币挖矿的难度值如何调整能满足每10分钟产生一个区块，并说明如何调整区块头中字段来调整挖矿难度？区块头当中的哪些字段能够调整用于生成满足当前难度目标值的区块头哈希值？**

比特币区块链采用了PoW共识机制。

比特币每产生2016个区块调整一次挖矿难度，通过调整挖矿难度来调整出块时间，新难度值=旧难度值×（过去2016个区块花费时长/20160分钟），一个块10分钟，挖矿难度的计算公式：难度值= 最大目标值/难度目标值（或难度目标值 = 最大目标值/难度值），最大目标值= 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF，难度目标值越小，区块生成难度值就越大。 这个难度目标值被保存在比特币的区块头中Bits字段中。

 

## SPV节点如何完成SPV验证（说明什么是Merkle Path Proof），Bloom Filter工作原理及SPV节点如何通过Bloom Filter完成指定交易的搜索。

Bloom过滤器数组里的每一个数的初始值为零。

关键词被加到Bloom过滤器中之前，会依次通过每个哈希函数运算一次。

关键词依次通过各哈希函数运算之后，相应的位变为1，Bloom过滤器则记录下该关键词。

Bloom过滤器正匹配代表着“可能是”，负匹配代表着“一定不是”。所以SPV节点若只关心某个支付到自己比特币地址的交易，则可通过建立布隆过滤器（布隆过滤器是一种基于哈希的高效查找结构，能够快速确定某个元素是否在一个集合内）限制只接收含有目标比特币地址的交易。一旦比特币网络中其他当节点探测到某个交易符合SPV节点设置的布隆过滤器条件时，其它节点将以Merkleblock消息的形式发送该区块，Merkleblock消息包含区块头和一条连接目标交易与Merkle根的Merkle路径。

SPV节点需要验证交易，需要做2个检查：交易的存在性检查和交易是否重花的检查。

SPV节点通过该Merkle路径找到跟该交易相关的区块，并验证对应区块中是否存在目标交易（该过程被称为：Merkle Path Proof）。SPV节点所收到的Merkleblock数据量通常少于1KB，只有一个完整区块（大约1MB）大小的千分之一左右。

现在通过Merkle Path Proof，SPV节点确认了交易确实存在于区块链中，但是这个还是无法保证这笔交易（Transaction）的Input（引用的上一笔UTXO）没有被重花（双重支付）。

这时候SPV节点通过去看这笔交易所在区块之后的区块个数，Block个数越多说明该区块被全网更多节点共识，一般来说，一笔交易所属区块之后的区块个数达到6个时，就说明这笔交易是被大家核准过（达成共识）的，没有重花，而且被篡改的可能性也很低。

Merkle Path Proof是指假设区块链系统中某个区块中存在A，B，C，D四笔交易，则为了确认交易C是否存在，需要得到交易C到Merkle Tree根节点上整条路径中的其余哈希值，以下图为例就是需要得到N3，N4哈希值，通过验证根节点的哈希一致性确认交易C存在于区块中。

 

## **什么是UTXO账本模型？如果我需要获得某个地址上的余额总数，该怎么做？和传统的账户模型有什么差别？**

比特币交易中的基础构建单元是交易输出。交易输出是比特币不可分割的基本组合，记录在区块上。比特币完整节点跟踪所有可找到的和可使用的输出，称为 “未花费的交易输出”即UTXO；所有UTXO的集合被称为UTXO集。比特币“余额”：用户钱包中可用UTXO总和，分散在多个交易和区块中。通过钱包所控制的密钥控制UTXO花费行为。UTXO是面值为“聪”的离散且不可分割的价值单元，一个UTXO只能在一次交易中作为一个整体被消耗。一笔比特币交易通过使用所有者的签名来解锁UTXO，并通过使用新的所有者的比特币地址来锁定并创建UTXO。

**UTXO** **模型的优点：**如果用户启用了新的地址用于转账和交易，新地址与原地址之间的关系很难被追踪，更好保证用户的隐私；UTXO 模型理论上来说可以并行地签发多笔交易，并广播到网络中；

 

## **比特币区块链有哪几种分叉，每种分叉的原因是什么？**

临时分叉：算法导致的分叉，通过最大工作量证明保证最终收敛性。

硬分叉：出现了旧规则禁止，新规则允许的行为。

软分叉：出现了旧规则允许，新规则禁止的行为。

 

## **举例说明比特币的链上扩容和链下扩容。**

链上扩容是在区块链基层协议上实现的扩容解决方案，它需要通过改变区块容量或者数据结构来达到提高处理交易能力的目的。包括：比特币采用的隔离见证+2MB硬分叉，比特币现金升级区块容量，以及以太坊分片技术

链下扩容是不改变公链基础协议的一种应用层上的扩展方案。它不改动区块链本身的规则。包括状态通道、侧链等解决方案。

 

## **举例说明侧链的典型应用场景。**

侧链技术就是为了方便数字资产在不同区块链间互相转移，在两条链完全独立的情况下，将不同的区块链互相连接在一起，以实现区块链的扩展，使两者能够“互相操作，实现交互”的一种跨区块链解决方案。

BTC Relay是一个典型应用场景，本质上是在以太坊上用合约重写了比特币的spv验证规则。其主要原理是把以太坊网络与比特币网络以一种安全去中心化的方式连接起来。通过使用以太坊的智能合约功能来验证比特币交易。BTC Relay使用区块头创建一种小型版本的比特币区块链，以太坊DApp开发者可以从智能合约向BTC Relay进行API调用来验证比特币网络活动。

 

## **说明闪电网络解决了比特币系统的什么问题及其如何解决的？**

比特币的交易网络，全网每秒 7 笔的交易速度，远低于传统的金融交易系统；同时，等待 6 个块的可信确认花费约 1 个小时的最终确认时间。闪电网络是将大量交易放到比特币区块链之外进行。闪电网络通过智能合约来完善链下的交易渠道。核心的概念主要有两个：RSMC和 HTLC。前者解决了链下交易的确认问题，后者解决了支付通道的问题。

## **以太坊解决了比特币的哪些问题？**

**1****缺少图灵完备性，**比特币不能支持所有的计算，如循环控制等。**2价值盲，**UTXO的不可分割性，使得其不能为账户的取款额度提供精细的控制。**3缺少状态，** UTXO只能用于建立简单的、一次性的合约，没有给需要任何其它内部状态的多阶段合约或者脚本留出生存空间。**4区块链盲，**UTXO看不到区块链的数据**5交易确认时间太长**。

 

## **以太坊的发展经历过那几个阶段，每个阶段进行了哪些重大升级？**

以太坊的发展分成四个阶段：Frontier、Homestead、Metropolis和Serenity。

 

## **简述以太坊技术体系，每层提供哪些功能服务。**

**应用层：**DApps，以太币钱包，以太币浏览器 **合约层**：Solidity，EVM，eWASM **激励层：**以太币，Gas**共识层：**PoW，PoW和PoS混合，PoS **网络层：**DEVp2p，RLPx，Discv4 **数据层：**数据结构，数据模型，分片技术，哈希函数，数字签名，非对称加密 **存储层：**LevelDB，ethdb模块，日志模块

 

## **简述以太坊区块结构，并说明区块头中的三棵树是如何构建的？有哪些作用。**

交易树：树叶里是交易
 收据树：树叶里是交易生成的收据
 状态数：树叶里是交易影响到的账户状态
 基于Merkle Patricia Trie/tree（MPT）构建三棵树，通过三棵树根哈希，分别建立于区块头相应字段的映射关系
 交易树根哈希：交易字典树根的RLP hash值（key：交易编号；Value：交易内容）
 收据树根哈希：收据字典树根的RLP hash值（key：索引编号；Value：收据内容）
 状态树根哈希：状态字典树根的RLP hash值（key：账户地址；Value：账户内容）

 

## **什么是Merkle Patricia Tree/Trie？为什么不能用Merkle Tree来存放以太坊账户状态？以太坊对其进行了哪些方面的优化？**

Patricia Trie，又称基数树，是一种存储空间优化的Trie树。

MPT（Merkle Patricia Trie/Tree）融合了Patricia Trie和Merkle Tree的优点。其中Merkle树用于交易存在和完整性的校验，Patricia树用于优化字典树的空间利用率，同时提升读写效率。

如果直接将Merkle Tree来存放以太坊账户状态，那么存放全球账户数据太多，占内存和存储空间，账户状态多变，修改困难。

**以太坊对其进行了以下方面的优化：**1）提高操作效率：引入多种类型节点和压缩前缀2）安全性：每节点利用其哈希被引用，可在LevelDB中查询；而非内存地址。

Key：节点的RLP编码的SHA3哈希值。

Value：节点的RLP编码。

想获得一个非叶节点的子节点，只需要根据子节点的hash访问数据库获得节点的RLP编码，然后解码。

 

## **以太坊账户类型有哪些？它们之间有何区别？**

对比项     外部拥有账户 合约账户 
 以太币余额   有       有
 输内容     交易      交易或消息
 控制       私钥     合约代码
 地址      公钥决定   由合约创建者地址和Nonce计算得
 代码      不包含代码   包含代码

 

## **什么是GHOST协议？相较比特币而言，为什么以太坊当中要奖励叔区块，如何奖励？**

GHOST协议解决当前快速确认的区块链因区块高作废率而受到低安全性困扰的问题。GHOST协议是根据最重子树选择主链。

相较比特币而言，以太坊产生区块的间隔时间更短，更易出现区块链分叉产生孤块，通过将产生孤块的算力也被包含进来，有效的增强了安全性。同时通过给叔区块奖励，避免出现像比特币那样计算力高度集中的矿池。 产生叔区块的矿工将获得的奖励为：（叔区块ID+8-当前区块ID）×区块奖励/8。将叔区块链接到区块链上的奖励为：每链接一个叔区块获得区块奖励/32个以太币的奖励，最多链接两个叔区块。

 

## **以太币和Gas有何关系？**

以太坊中两种不同的计量单位gas存在于EVM中；

ether存在于以太坊账户中。

gas用来衡量执行每一步操作所需要支付的费用，其价格由ether来表示。

用户可以通过向以太坊账户中充值以太币，由以太坊客户端自动购买用户指定操作最大支出的gas，同时在操作结束时将剩余的gas转换成以太币返还到用户的以太坊账户。gas与以太币两者分开，gas单位与具备自然成本的运算单位一致，而ether的价格通常会由于市场力量产生波动。

 

## **以太坊虚拟机可访问存储数据的空间有哪些？ 各自有何特点？**

**Storage****（账户存储）**每个账户有一块保存在区块链上的持久性存储，称为 storage。这是一个将256位字映射到256位字的 key-value 存储区，均为32字节；未使用Key-Value值为0，非0值代表已占用。永久储存在区块链中，读写的 gas 开销也最大。

**Memory****（内存）**每一次消息调用，会临时获取一块干净的内存空间。生命周期仅为整个方法执行期间，函数调用后回收，按照可寻址字节数组来存储，读写 gas 开销较小。

**Stack****（栈）**EVM是基于栈的，几乎免费使用的内存，但有数量限制。栈中每个元素是32字节，最多容1024个元素。

 

## **简述以太坊挖矿算法Ethash的过程，并说明为何它可做到ASIC resistance？**

第一步：生成种子，根据区块块头信息计算出一个种子。

第二步：伪随机数据集，根据种子生成一个大小为16M的伪随机数据集，每30000个区块进行一次更新，用于轻客户端存储缓存。

第三步：DAG数据集，根据伪随机数据集生成大小1G的大规模数据集。该数据集中每项元素通过伪随机数据集中少量的几项计算得到。

第四步：挖矿，通过header及nonce计算出一个初始的哈希值映射到初始位置A，然后读取A位置元素和A的相邻后一个位置A'的元素，再通过（A和A'）计算出位置（B和B'），以此类推，迭代64次后，一共读取出128个数，最后计算这128个数的哈希值与目标值target比较，若满足target，则挖矿成功；否则重新尝试nonce。ASIC芯片主要优势是算力强，但在内存访问的性能上没有那么大的优势，所以能设计出一个对内存要求很高的puzzle，就能起到遏制ASIC芯片的作用。



# 复习简化[confucian-e](https://github.com/CUIT-Blockchain/Crypto-Currency/blob/main/crypto-currency/Summary.md)

## BlockChain

> 为什么说区块链技术应用是从信息互联网到价值互联网

（围绕“不可复制”、“确权”、“价值交换”）。

> 区块链部署的三种形式，每种形式的特点，我国以哪种为主

- 公有链：节点加入无需准许，人人都可参与网络共识，任意读取数据，执行交易；PoW、PoS等。
- 联盟链：节点加入需要准许，多个机构组成联盟，数据读写等操作由联盟成员决定，效率高，节点可信度高；PBFT、Raft等。
- 私有链：写入权限掌握在一个组织内部，读取或开放或限制。

国内以联盟链为主。

> 区块链的六层架构

- 应用层：dapp
- 合约层：智能合约
- 激励层：挖矿
- 共识层：共识机制
- 网络层：P2P
- 数据层：数据结构，数据库

> 公有链激励层中的分配机制和发行机制

- 发行
  - ICO
  - IPO
  - IEO
  - 公私募
- 分配
  - 空投
  - 流动性挖矿
  - 质押挖矿
  - 社区成员分配

## Bitcoin

> 比特币区块头数据结构，每个字段长度及意义

区块头包含：上一个区块头哈希、默克尔树根哈希、版本号、时间戳、当前挖矿难度、随机数；共80个字节，前2个各32位，后4个各4位。

> 比特币密钥和地址生成过程，为什么通过地址推导公钥哈希

私钥：256位由0和1组成的随机数，以64位16进制显示。

公钥：私钥通过一个椭圆曲线算法(ECDSA)计算而来，不可逆，即不能根据公钥倒推私钥。

地址：公钥先通过单向哈希(SHA256, RIPEMD160)计算出公钥哈希，公钥哈希通过Base58check编码得到地址。

因为地址是公钥哈希通过Base58check编码得来的，所以地址逆向变换可得公钥哈希。

> 比特币交易流程

1. 交易的创建：线上线下都可。
2. 广播交易：广播到P2P网络，全网节点收到验证。
3. 交易验证与挖矿：从交易池中选一系列交易，矿工挖出区块。
4. 交易确认：待新块中全部交易验证完成后，各节点将该块添加到区块链尾部（上链）。
5. 确认有效：经过6个区块（1个小时）确认后即有效，永久保存于链上。

> 锁定脚本与解锁脚本位置

锁定脚本在输入列表中，解锁脚本在输出列表中。

> P2PKH执行过程，出入栈变化

1. 签名(sig)入栈。
2. 公钥(PubK)入栈。
3. 复制栈顶的公钥(DUP)。
4. 对栈顶的公钥进行哈希(HASH160)。
5. 压入公钥哈希(PubKHash)。
6. 判断栈顶的2个公钥哈希是否相等(EQUALVERIFY)，相等后这2个出栈。
7. 根据公钥检验签名(CHECKSIG)，正确后都出栈，栈顶显示TRUE。

> 比特币分叉类型及原因

- 临时分叉：算法导致，同时挖出2个甚至多个块。
- 硬分叉：升级系统，新规则无法向前兼容，旧节点无法认可新节点的区块。
- 软分叉：升级系统，可以向前兼容。

## Ethereum

> 以太坊解决了比特币的哪些问题

- 缺少图灵完备：比特币脚本语言非图灵完备。
- 价值盲：UTXO不可分割，转账金额不能精细控制。
- 缺少状态：UTXO只有是否花费，不能构建复杂合约。
- 区块链盲：看不到区块链的数据
- 速度慢：交易确认时间长，TPS低

> 以太坊发展的4个阶段

1. 前沿(Frontier)
2. 家园(Homestead)
3. 大都会(Metropolis)
4. 宁静(Serenity)

> 以太坊区块头的三棵树及作用

- 交易树：存交易
- 收据树：存交易生成的收据
- 状态树：存账户状态

> 以太坊账户类型

外部拥有账户(EOA)和合约账户(CA)

> 以太币(ether)与gas的区别

以太坊中2种不同的计量单位。

gas存在于EVM中；ether存在于以太坊账户中，最小货币单位为wei。

gas用来衡量执行每一步操作所需要支付的费用，其价格由ether来表示。

> 以太坊虚拟机可访问存储数据的空间有哪些，各自特点

- Storage：链上永久存储，gas开销大。
- Memory：临时存储，生命周期为方法执行期间，gas开销小。
- Stack：EVM不是基于寄存器，而是基于栈。

 
